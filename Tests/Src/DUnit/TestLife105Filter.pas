unit TestLife105Filter;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, UStructs, Engine.UPattern, Engine.UGrid, Generics.Collections,
  Types, Classes, SysUtils, Filters.ULife105, Engine.UCommon, Engine.URules;

type
  // Test methods for class TLife105Reader
  TestTLife105Reader = class(TTestCase)
  strict private
    fReader: TLife105Reader;
    fPattern: TPattern;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestLoadFromFile;
    procedure TestLoadFromStream;
  end;

  // Test methods for class TLife105Writer
  // NOTE: run these tests after those for TLife105Reader because they use
  // TLife105Reader as part of tests
  TestTLife105Writer = class(TTestCase)
  strict private
    fWriter: TLife105Writer;
    fPattern: TPattern;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestSaveToStream;
  end;

implementation

const
  PatQuadPole: array[0..6] of string = (
    '1100000',
    '1010000',
    '0000000',
    '0010100',
    '0000000',
    '0000101',
    '0000011'
  );

  Pat2Fumaroles: array[0..11] of string = (
    '110000000000000',
    '100110000100000',
    '011011000100000',
    '000011000100000',
    '000011000000000',
    '011011000011000',
    '100110001000010',
    '110000001000010',
    '000000001000010',
    '000000000100100',
    '000000010100101',
    '000000011000011'
  );

  PatMultiPatterns: array[0..11] of string = (
    '0011001100001111000',
    '0001111000001111000',
    '0000110000000000000',
    '0001111000011110000',
    '0011001100011110000',
    '0000000000000000000',
    '1110000000000000111',
    '0000000000000000000',
    '0000000011111000000',
    '0000000101010100000',
    '0000000011111000000',
    '0000000101010100000'
  );

const
  // Life 1.05 source for PatMultiPatterns split into patterns per comments
  // above. No comments. Rule = B3/S12345
  SrcMultiPatterns: array[0..30] of string = (
    '#Life 1.05',
    '#R 12345/3',    // Maze rule
    '#P -4 -5',
    '**..**',
    '.****',
    '..**',
    '.****.',
    '**..**',
    '',
    '#P 5 -5',
    '.****',
    '.****',
    '.',
    '****',
    '****',
    '#P -6 1',
    '***',
    '',
    '',
    '',
    '#P 10 1',
    '***',
    '#P 1 3',
    '',
    '.*****',
    '',
    '*.*.*.*',
    '',
    '#P 1 5',
    '.*****.',  // test for trailing OFF cell
    '*.*.*.*'
  );

const
  PatOverlapped: array[0..2] of string = (
    '0110',
    '1111',
    '0110'
  );

  // Life 1.05 source for PatOverlapped split into 2 patterns. No rule
  // specified. Uses a 0,0 top left offset.
  SrcOverlapped0x0: array[0..7] of string = (
    '#Life 1.05',
    '#D   Test for overlapped patterns 0x0 ',
    '#P 1 0',
    '**',
    '.',
    '**',
    '#P 0 1',
    '****'
  );

  // Life 1.05 source for PatOverlapped split into 2 patterns. No rule
  // specified. Uses a 3,4 top left offset: gives same grid as SrcOverlapped0x0.
  SrcOverlapped3x4: array[0..7] of string = (
    '#Life 1.05',
    '#D   Test for overlapped patterns 3x4  ',
    '#P 4 4',
    '**',
    '.',
    '**',
    '#P 3 5',
    '****'
  );

  PatWidePattern: array[0..16] of string = (
    '00000000000000000000000000000000000000000000000000000000000000000000000000'
    + '000000000000000000000000000000000000000000000000000000000000000000000000'
    + '0000000000000000',
    '00000000000000000000000000000000000000000000000000000000000000000000000000'
    + '000000000000000000000000000000000000000000000000000000000000000000000000'
    + '0000000000000000',
    '00000000010100000000000000000000000000000000000000000000000000000000101100'
    + '000000000000010000000000000000000000000000000000000000000000000000000000'
    + '0000000000000000',
    '00000001000100000000000000000000000000000000000000000000000000000000100100'
    + '000000000000010100000000000000000000000000000000000000000000000000000000'
    + '0000000000000000',
    '00000000000000000000000100100000000000000000000000000000000000000000000000'
    + '000000000000000000000000000001100000000000000101000000000100000000000000'
    + '0000000000000000',
    '00000000000000000000000110000000000000000000000000000000000000000000000000'
    + '000000000000000000000000000001000000000000000011000000001111000000000000'
    + '0000000000000111',
    '00000000000000000000000000000000000000110000000000000000000000000000000000'
    + '000000000000000000101000000101000000000000000000000000011010000000011000'
    + '0000000000000001',
    '00000000000000000000000000000000000000100000000000000000000000000000000000'
    + '000000000000000000100100000110000000000000000000000000111010100000010010'
    + '0000000000000010',
    '00000000000000000000000000110000000010100000000000000000000000000000000000'
    + '000100000000000000000110000000000000000000000000000000011010000000000001'
    + '0000000000000000',
    '00000000000000000000000000001000000011000000000000000000000000000000000000'
    + '001010000000000000010001100000000000000000000110000000001111000000000001'
    + '0000001100010010',
    '00000000000000011000000000000100000000000000000000000000110000000000000000'
    + '010110000000000000000110000000000000000000001001000000000100000000000001'
    + '0000001111111111',
    '00000000000000010000000000000100000000000000000000000000100000000000000000'
    + '110110000000000000100100000011000000000000001000000000000000000000010010'
    + '0000000111000111',
    '00000000000011000000000000000100000000000000000000000000011100000000000000'
    + '010110000000000000101000000100100000000000001000000000000000000000011000'
    + '0000000001111100',
    '00001100000111000000000000001000000001100000000000000000000100000000000110'
    + '001010000000000000000000000000100000000000001011000000000000000000000000'
    + '000000000111101',
    '00001000000011000000000000110000000001000000000000000000000000100000001010'
    + '000100000000000000000000000000100000000000000010000000010000000000000000'
    + '0000000000000010',
    '00000000000000010000000000000000000000000000000110000000000001000000001000'
    + '000000000000000000000000000110100000000000000000000001100000000000000000'
    + '0000000000000000',
    '00000000000000000000000000000000000000000000000000000000000000000000000000'
    + '000000000000000000000000000000000000000000000000000000000000000000000000'
    + '0000000000000000'
  );

procedure SetupGrid(const G: TGrid; Pat: array of string);
var
  X, Y: Integer;
begin
  G.Initialise;
  for Y := 0 to Pred(G.Size.CY) do
    for X := 0 to Pred(G.Size.CX) do
      if Pat[Y, X+1] = '1' then
        G[X, Y] := csOn;
end;

procedure StrArrayToStream(const A: array of string; const Stm: TStream);
var
  SL: TStringList;
  S: string;
begin
  SL := TStringList.Create;
  try
    for S in A do
      SL.Add(S);
    SL.SaveToStream(Stm, TEncoding.ASCII);
    Stm.Position := 0;
  finally
    SL.Free;
  end;
end;

procedure TestTLife105Reader.SetUp;
begin
  fReader := TLife105Reader.Create;
  fPattern := TPattern.Create;
end;

procedure TestTLife105Reader.TearDown;
begin
  fReader.Free;
  fPattern.Free;
end;

procedure TestTLife105Reader.TestLoadFromFile;
var
  FileName: TFileName;
  G: TGrid;
begin
  FileName := ExtractFilePath(ParamStr(0)) + '..\Files\quadpole_105.lif';
  fReader.LoadFromFile(fPattern, FileName);
  G := TGrid.Create;
  try
    G.Size := TSizeEx.Create(7, 7);
    SetupGrid(G, PatQuadPole);
    CheckTrue(G.IsEqual(fPattern.Grid), 'Test 1: Grid');
    CheckEquals(3, fPattern.Description.Count, 'Test 1: Description.Count');
    CheckEquals(
      'Name: Quadpole',
      fPattern.Description[0], 'Test 1: Description[0]'
    );
    CheckEquals(
      'The barberpole of length 4.',
      fPattern.Description[1], 'Test 1: Description[1]'
    );
    CheckEquals(
      'www.conwaylife.com/wiki/index.php?title=Quadpole',
      fPattern.Description[2], 'Test 1: Description[2]'
    );
    CheckEquals('23/3', fPattern.Rule.ToString, 'Test 1: Rule');
  finally
    G.Free;
  end;

  FileName := ExtractFilePath(ParamStr(0)) + '..\Files\2fumaroles_105.lif';
  fReader.LoadFromFile(fPattern, FileName);
  G := TGrid.Create;
  try
    G.Size := TSizeEx.Create(15, 12);
    SetupGrid(G, Pat2Fumaroles);
    CheckTrue(G.IsEqual(fPattern.Grid), 'Test 2: Grid');
    CheckEquals(5, fPattern.Description.Count, 'Test 2: Description.Count');
    CheckEquals(
      'Name: 2 fumaroles',
      fPattern.Description[0], 'Test 2: Description[0]'
    );
    CheckEquals(
      'Author: Noam Elkies',
      fPattern.Description[1], 'Test 2: Description[1]'
    );
    CheckEquals(
      'A non-trivial combination of two fumaroles and a blinker, '
      + 'found on September',
      fPattern.Description[2], 'Test 2: Description[2]'
    );
    CheckEquals(
      '1, 1995.',
      fPattern.Description[3], 'Test 2: Description[3]'
    );
    CheckEquals(
      'www.conwaylife.com/wiki/index.php?title=Fumarole',
      fPattern.Description[4], 'Test 2: Description[4]'
    );
    CheckEquals('23/3', fPattern.Rule.ToString, 'Test 2: Rule');
  finally
    G.Free;
  end;
end;

procedure TestTLife105Reader.TestLoadFromStream;
var
  Stm: TStringStream;
  G: TGrid;
begin
  // This tests multiple patterns
  Stm := TStringStream.Create('', TEncoding.ASCII);
  try
    StrArrayToStream(SrcMultiPatterns, Stm);
    fReader.LoadFromStream(fPattern, Stm);
  finally
    Stm.Free;
  end;
  G := TGrid.Create;
  try
    G.Size := TSizeEx.Create(19, 12);
    SetupGrid(G, PatMultiPatterns);
    CheckTrue(G.IsEqual(fPattern.Grid), 'Test 1: Grid');
    CheckEquals(0, fPattern.Description.Count, 'Test 1: Description.Count');
    CheckEquals('12345/3', fPattern.Rule.ToString, 'Test 1: Rule');
  finally
    G.Free;
  end;
  Stm := TStringStream.Create('', TEncoding.ASCII);
  try
    StrArrayToStream(SrcOverlapped0x0, Stm);
    fReader.LoadFromStream(fPattern, Stm);
  finally
    Stm.Free;
  end;
  G := TGrid.Create;
  try
    G.Size := TSizeEx.Create(4, 3);
    SetupGrid(G, PatOverlapped);
    CheckTrue(G.IsEqual(fPattern.Grid), 'Test 2: Grid');
    CheckEquals(1, fPattern.Description.Count, 'Test 2: Description.Count');
    CheckEquals(
      'Test for overlapped patterns 0x0',
      fPattern.Description[0], 'Test 2: Description[0]'
    );
    CheckTrue(fPattern.Rule.IsNull, 'Test 2: Rule');
  finally
    G.Free;
  end;
  Stm := TStringStream.Create('', TEncoding.ASCII);
  try
    StrArrayToStream(SrcOverlapped3x4, Stm);
    fReader.LoadFromStream(fPattern, Stm);
  finally
    Stm.Free;
  end;
  G := TGrid.Create;
  try
    G.Size := TSizeEx.Create(4, 3);
    SetupGrid(G, PatOverlapped);
    CheckTrue(G.IsEqual(fPattern.Grid), 'Test 3: Grid');
    CheckEquals(1, fPattern.Description.Count, 'Test 3: Description.Count');
    CheckEquals(
      'Test for overlapped patterns 3x4',
      fPattern.Description[0], 'Test 3: Description[0]'
    );
    CheckTrue(fPattern.Rule.IsNull, 'Test 3: Rule');
  finally
    G.Free;
  end;
end;

procedure TestTLife105Writer.SetUp;
begin
  fWriter := TLife105Writer.Create;
  fPattern := TPattern.Create;
end;

procedure TestTLife105Writer.TearDown;
begin
  fWriter.Free;
  fPattern.Free;
end;

procedure TestTLife105Writer.TestSaveToStream;
var
  Stm: TStringStream;
  Reader: TLife105Reader;
  P: TPattern;
  I: Integer;
begin
  fPattern.Grid.Size := TSizeEx.Create(15, 12);
  SetupGrid(fPattern.Grid, Pat2Fumaroles);
  fPattern.Rule := TRule.Create([3], [2,3]);
  fPattern.Name := 'Suspendisse potenti. Maecenas nec est eros, non placerat '
    + 'massa viverra fusce lacinia et ornare id.'; // tests longer max length
  fPattern.Author := 'Noam Elkies';
  fPattern.Description.Add('Lorem ipsum dolor sit amet.');
  fPattern.Description.Add( // tests wrapping of long lines
    'Maecenas nec est eros non placerat. Cras erat sem, lacinia et ornare id, '
    + 'volutpat id lacus. Vestibulum eu.'
  );
  for I := 5 to 24 do   // test for enforcement of max of 22 comment lines
    fPattern.Description.Add('More description');
  P := nil;
  Reader := nil;
  Stm := TStringStream.Create('', TEncoding.ASCII);
  try
    Reader := TLife105Reader.Create;
    P := TPattern.Create;
    fWriter.SaveToStream(fPattern, Stm);
    Stm.Position := 0;
    Reader.LoadFromStream(P, Stm);
    CheckTrue(P.Grid.IsEqual(fPattern.Grid), 'Test 1: Grid');
    CheckEquals(22, P.Description.Count, 'Test 1: Description.Count');
    CheckTrue(
      fPattern.Description.Count + 2{for name & author} > P.Description.Count,
      'Test 1: Max description lines'
    );
    CheckEquals(
      'Name: Suspendisse potenti. Maecenas nec est eros, non placerat massa '
        + 'viver...',
      P.Description[0],
      'Test 1: Description[0] (Name)'
    );
    CheckEquals(
      'Author: Noam Elkies',
      P.Description[1],
      'Test 1: Description[1] (Author)'
    );
    CheckEquals(
      'Lorem ipsum dolor sit amet.',
      P.Description[2],
      'Test 1: Description[2]'
    );
    CheckEquals(
      'Maecenas nec est eros non placerat. Cras erat sem, lacinia et ornare '
      + 'id,',
      P.Description[3],
      'Test 1: Description[3]'
    );
    CheckEquals(
      'volutpat id lacus. Vestibulum eu.',
      P.Description[4],
      'Test 1: Description[4]'
    );
    CheckEquals('23/3', P.Rule.ToString, 'Test 1: Rule');
  finally
    P.Free;
    Reader.Free;
    Stm.Free;
  end;

  // Multi-part file: grid wider than 80 cols
  fPattern.Grid.Size := TSizeEx.Create(162, 17);
  SetupGrid(fPattern.Grid, PatWidePattern);
  fPattern.Rule := TRule.Create([1,2], [2,3]);
  fPattern.Name := ''; // tests longer max length
  fPattern.Author := '';
  fPattern.Description.Clear;
  P := nil;
  Reader := nil;
  Stm := TStringStream.Create('', TEncoding.ASCII);
  try
    Reader := TLife105Reader.Create;
    P := TPattern.Create;
    fWriter.SaveToStream(fPattern, Stm);
    Stm.Position := 0;
    Reader.LoadFromStream(P, Stm);
    CheckTrue(P.Grid.IsEqual(fPattern.Grid), 'Test 2: Grid');
    CheckEquals(0, P.Description.Count, 'Test 2: Description.Count');
    CheckEquals('23/12', P.Rule.ToString, 'Test 2: Rule');
  finally
    P.Free;
    Reader.Free;
    Stm.Free;
  end;
end;

initialization

  Randomize;

  // Register any test cases with the test runner
  RegisterTest(TestTLife105Reader.Suite);
  RegisterTest(TestTLife105Writer.Suite);

end.

