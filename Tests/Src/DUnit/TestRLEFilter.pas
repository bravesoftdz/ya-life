unit TestRLEFilter;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, SysUtils, Types, Generics.Collections, Engine.UPattern,
  Engine.UGrid, Engine.UCommon, Classes, Filters.URLE, UStructs;

type
  // Test methods for class TRLEReader
  TestTRLEReader = class(TTestCase)
  strict private
    fReader: TRLEReader;
    fPattern: TPattern;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestLoadFromFile;
  end;

  // Test methods for class TRLEWriter
  // NOTE: run these tests after those for TRLEReader because they use
  // TRLEReader as part of tests
  TestTRLEWriter = class(TTestCase)
  strict private
    fWriter: TRLEWriter;
    fPattern: TPattern;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestWriteToStream;
  end;

implementation

uses
  Engine.URules;

const
  Pat20P2: array[0..10] of string = (
    '01100000',
    '01000000',
    '00001000',
    '00011000',
    '00000000',
    '01111000',
    '10000100',
    '11001010',
    '00001001',
    '00000101',
    '00000010'
  );

  PatAcorn: array[0..2] of string = (
    '0100000',
    '0001000',
    '1100111'
  );

  PatQuasar: array[0..28] of string = (
    'OOOOOOOOOO111OOO111OOOOOOOOOO',
    'OOOOOOOOOOOOOOOOOOOOOOOOOOOOO',
    'OOOOOOOO1OOOO1O1OOOO1OOOOOOOO',
    'OOOOOOOO1OOOO1O1OOOO1OOOOOOOO',
    'OOOOOOOO1OOOO1O1OOOO1OOOOOOOO',
    'OOOOOOOOOO111OOO111OOOOOOOOOO',
    'OOOOOOOOOOOOOOOOOOOOOOOOOOOOO',
    'OOOOOOOO111OOOOOOO111OOOOOOOO',
    'OO111OO1OOOO1OOO1OOOO1OO111OO',
    'OOOOOOO1OOOO1OOO1OOOO1OOOOOOO',
    '1OOOO1O1OOOO1OOO1OOOO1O1OOOO1',
    '1OOOO1OOOOOOOOOOOOOOOOO1OOOO1',
    '1OOOO1OO111OOOOOOO111OO1OOOO1',
    'OO111OOOOOOOOOOOOOOOOOOO111OO',
    'OOOOOOOOOOOOOOOOOOOOOOOOOOOOO',
    'OO111OOOOOOOOOOOOOOOOOOO111OO',
    '1OOOO1OO111OOOOOOO111OO1OOOO1',
    '1OOOO1OOOOOOOOOOOOOOOOO1OOOO1',
    '1OOOO1O1OOOO1OOO1OOOO1O1OOOO1',
    'OOOOOOO1OOOO1OOO1OOOO1OOOOOOO',
    'OO111OO1OOOO1OOO1OOOO1OO111OO',
    'OOOOOOOO111OOOOOOO111OOOOOOOO',
    'OOOOOOOOOOOOOOOOOOOOOOOOOOOOO',
    'OOOOOOOOOO111OOO111OOOOOOOOOO',
    'OOOOOOOO1OOOO1O1OOOO1OOOOOOOO',
    'OOOOOOOO1OOOO1O1OOOO1OOOOOOOO',
    'OOOOOOOO1OOOO1O1OOOO1OOOOOOOO',
    'OOOOOOOOOOOOOOOOOOOOOOOOOOOOO',
    'OOOOOOOOOO111OOO111OOOOOOOOOO'
  );



procedure SetupGrid(const G: TGrid; Pat: array of string);
var
  X, Y: Integer;
begin
  G.Initialise;
  for Y := 0 to Pred(G.Size.CY) do
    for X := 0 to Pred(G.Size.CX) do
      if Pat[Y, X+1] = '1' then
        G[X, Y] := csOn;
end;

function CheckLineLengths(Lines: TStrings): Boolean;
var
  Line: string;
begin
  for Line in Lines do
    if Length(Line) > 70 then
      Exit(False); // 70 is max length of RLE file line
  Result := True;
end;

{ TestTRLEReader }

procedure TestTRLEReader.SetUp;
begin
  fReader := TRLEReader.Create;
  fPattern := TPattern.Create;
end;

procedure TestTRLEReader.TearDown;
begin
  fReader.Free;
  fPattern.Free;
end;

procedure TestTRLEReader.TestLoadFromFile;
var
  FileName: TFileName;
  SL: TStringList;
  G: TGrid;
begin
  // This test also tests LoadFromStream because LoadFromFile simply opens a
  // file stream and calls LoadFromStream. If the implementation is changed, a
  // separate test will be needed for LoadFromStream.
  G := nil;
  SL := TStringList.Create;
  try
    G := TGrid.Create;

    // 20P2 pattern
    FileName := ExtractFilePath(ParamStr(0)) + '..\Files\20p2.rle';
    SL.Clear;
    SL.Add('The 34th most common oscillator.');
    SL.Add('www.conwaylife.com/wiki/index.php?title=20P2');
    SL.Add('Altered rule for test');
    SL.Add('Old style');
    SL.Add('comments');
    G.Size := TSizeEx.Create(8, 11);
    SetupGrid(G, Pat20P2);
    fReader.LoadFromFile(fPattern, FileName);
    CheckEquals(8, fPattern.Grid.Size.CX, 'Test 1 Grid.Size.CX');
    CheckEquals(11, fPattern.Grid.Size.CY, 'Test 1 Grid.Size.CY');
    CheckEquals(Ord(poCentre), Ord(fPattern.Origin), 'Test 1 Origin');
    // don't test fPattern.Offset when Origin = poCentre
    CheckEquals('B3/S12345', fPattern.Rule.ToBSString, 'Test 1 Rule');
    CheckEquals('20P2', fPattern.Name, 'Test 1 Name');
    CheckEquals('', fPattern.Author, 'Test 1 Author');
    CheckEquals(SL.Text, fPattern.Description.Text, 'Test 1 Description');
    CheckTrue(G.IsEqual(fPattern.Grid), 'Test 1 Grid');

    // Acorn pattern
    FileName := ExtractFilePath(ParamStr(0)) + '..\Files\acorn.rle';
    SL.Clear;
    SL.Add('A methuselah with lifespan 5206.');
    SL.Add('www.conwaylife.com/wiki/index.php?title=Acorn');
    SL.Add('Altered rule for test + added offest');
    G.Size := TSizeEx.Create(7,3);
    SetupGrid(G, PatAcorn);
    fReader.LoadFromFile(fPattern, FileName);
    CheckEquals(7, fPattern.Grid.Size.CX, 'Test 2 Grid.Size.CX');
    CheckEquals(3, fPattern.Grid.Size.CY, 'Test 2 Grid.Size.CY');
    CheckEquals(Ord(poCentreOffset), Ord(fPattern.Origin), 'Test 2 Origin');
    CheckEquals(-10, fPattern.Offset.X, 'Test 2 Offset.X');
    CheckEquals(-3, fPattern.Offset.Y, 'Test 2 Offset.Y');
    CheckEquals('B36/S125', fPattern.Rule.ToBSString, 'Test 2 Rule');
    CheckEquals('Acorn', fPattern.Name, 'Test 2 Name');
    CheckEquals('Charles Corderman', fPattern.Author, 'Test 2 Author');
    CheckEquals(SL.Text, fPattern.Description.Text, 'Test 2 Description');
    CheckTrue(G.IsEqual(fPattern.Grid), 'Test 2 Grid');

    // Quasar pattern
    FileName := ExtractFilePath(ParamStr(0)) + '..\Files\quasar.rle';
    SL.Clear;
    SL.Add(
      'A period 3 oscillator found in August 1971 that is quite similar to'
    );
    SL.Add('the pulsar.');
    SL.Add('www.conwaylife.com/wiki/index.php?title=Quasar');
    SL.Add('Conway Life Rule Implied for test and author deleted');
    G.Size := TSizeEx.Create(29,29);
    SetupGrid(G, PatQuasar);
    fReader.LoadFromFile(fPattern, FileName);
    CheckEquals(29, fPattern.Grid.Size.CX, 'Test 3 Grid.Size.CX');
    CheckEquals(29, fPattern.Grid.Size.CY, 'Test 3 Grid.Size.CY');
    CheckEquals(Ord(poCentre), Ord(fPattern.Origin), 'Test 3 Origin');
    // don't test fPattern.Offset when Origin = poCentre
    CheckEquals('B3/S23', fPattern.Rule.ToBSString, 'Test 3 Rule');
    CheckEquals('Quasar', fPattern.Name, 'Test 3 Name');
    CheckEquals('', fPattern.Author, 'Test 3 Author');
    CheckEquals(SL.Text, fPattern.Description.Text, 'Test 3 Description');
    CheckTrue(G.IsEqual(fPattern.Grid), 'Test 3 Grid');
  finally
    SL.Free;
    G.Free;
  end;
end;

procedure TestTRLEWriter.SetUp;
begin
  fWriter := TRLEWriter.Create;
  fPattern := TPattern.Create;
end;

procedure TestTRLEWriter.TearDown;
begin
  fPattern.Free;
  fWriter.Free;
end;

procedure TestTRLEWriter.TestWriteToStream;
var
  Stm: TStringStream;
  P: TPattern;
  R: TRLEReader;
  SL: TStringList;
begin
  P := nil;
  R := nil;
  SL := nil;
  try
    SL := TStringList.Create;
    P := TPattern.Create;
    R := TRLEReader.Create;

    // Test with 20P2 pattern: should have single patter line
    fPattern.Name := 'Suspendisse potenti. Maecenas nec est eros, non placerat '
      + 'massa viverra fusce.'; // tests lines longer than RLE file max length
    fPattern.Author := 'John Smith';
    fPattern.Description.Add('Lorem ipsum dolor sit amet.');
    fPattern.Description.Add( // tests wrapping of long lines
      'Cras erat sem, lacinia et ornare id, volutpat id lacus. Vestibulum eu.'
    );
    fPattern.Origin := poCentreOffset;
    fPattern.Offset := Point(-12, -7);
    fPattern.Rule := TRule.Create('B245/S67');
    fPattern.Grid.Size := TSizeEx.Create(8, 11);
    SetupGrid(fPattern.Grid, Pat20P2);
    Stm := TStringStream.Create('', TEncoding.Default);
    try
      fWriter.SaveToStream(fPattern, Stm);
      Stm.Position := 0;
      R.LoadFromStream(P, Stm);
      Stm.Position := 0;
      SL.LoadFromStream(Stm, TEncoding.Default);
      // test reloaded pattern for correct properties
      CheckTrue(P.Grid.IsEqual(fPattern.Grid), 'Test 1 Grid');
      CheckEquals(
        'Suspendisse potenti. Maecenas nec est eros, non placerat massa v...',
        P.Name,
        'Test 1 Name'
      );
      CheckEquals('John Smith', P.Author, 'Test 1 Author');
      CheckEquals(3, P.Description.Count, 'Test 1 Description.Count');
      CheckEquals(
        'Lorem ipsum dolor sit amet.', P.Description[0], 'Test 1 Description[0]'
      );
      CheckEquals(
        'Cras erat sem, lacinia et ornare id, volutpat id lacus. Vestibulum',
        P.Description[1], 'Test 1 Description[1]'
      );
      CheckEquals(
        'eu.', P.Description[2], 'Test 1 Description[2]'
      );
      CheckEquals(Ord(poCentreOffset), Ord(P.Origin), 'Test 1 Origin');
      CheckEquals(-12, P.Offset.X, 'Test 1 Offset.X');
      CheckEquals(-7, P.Offset.Y, 'Test 1 Offset.Y');
      CheckEquals(8, P.Grid.Size.CX, 'Test 1 Grid.Size.CX');
      CheckEquals(11, P.Grid.Size.CY, 'Test 1 Grid.Size.CY');
      CheckEquals('B245/S67', P.Rule.ToBSString, 'Test 1 Rule');
      // check hash lines and header line from generated stream
      CheckTrue(CheckLineLengths(SL));
      CheckEquals(
        '#N '
        + 'Suspendisse potenti. Maecenas nec est eros, non placerat massa v...',
        SL[0], 'Test 1 #N'
      );
      CheckEquals('#O John Smith', SL[1], 'Test 1 #O');
      CheckEquals('#C Lorem ipsum dolor sit amet.', SL[2], 'Test 1 #C 1');
      CheckEquals(
        '#C Cras erat sem, lacinia et ornare id, volutpat id lacus. Vestibulum',
        SL[3], 'Test 1 C 2'
      );
      CheckEquals('#C eu.', SL[4], 'Test 1 #C 4');
      CheckEquals('#R -12 -7', SL[5], 'Test 1 #P');
      CheckEquals(
        'x = 8, y = 11, rule = 67/245', SL[6], 'Test 1 Header line'
      );
    finally
      Stm.Free;
    end;

    // Test with Quasar pattern: will result in wrapper pattern lines
    fPattern.Name := 'Quasar';
    fPattern.Author := 'Robert Wainwright';
    fPattern.Description.Clear;         // no description
    fPattern.Origin := poCentre;        // no offset
    fPattern.Rule := TRule.CreateNull;  // no rule
    fPattern.Grid.Size := TSizeEx.Create(29, 29);
    SetupGrid(fPattern.Grid, PatQuasar);
    Stm := TStringStream.Create('', TEncoding.Default);
    try
      fWriter.SaveToStream(fPattern, Stm);
      Stm.Position := 0;
      R.LoadFromStream(P, Stm);
      Stm.Position := 0;
      SL.LoadFromStream(Stm, TEncoding.Default);
      // test re-loaded pattern for corrected properties
      CheckTrue(P.Grid.IsEqual(fPattern.Grid), 'Test 2 Grid');
      CheckEquals(P.Name, 'Quasar', 'Test 2 Name');
      CheckEquals(P.Author, 'Robert Wainwright', 'Test 2 Author');
      CheckEquals(0, P.Description.Count, 'Test 2 Description.Count');
      CheckEquals(Ord(poCentre), Ord(P.Origin), 'Test 2 Origin');
      CheckEquals(29, P.Grid.Size.CX, 'Test 2 Grid.Size.CX');
      CheckEquals(29, P.Grid.Size.CY, 'Test 2 Grid.Size.CY');
      CheckEquals('B3/S23', P.Rule.ToBSString, 'Test 2 Rule');
      // check hash lines and header line from generated stream
      CheckTrue(CheckLineLengths(SL));
      CheckEquals(
        '#N Quasar', SL[0], 'Test 2 #N'
      );
      CheckEquals('#O Robert Wainwright', SL[1], 'Test 2 #O');
      CheckEquals(
        'x = 29, y = 29', SL[2], 'Test 2 Header line'
      );
    finally
      Stm.Free;
    end;

  finally
    R.Free;
    P.Free;
    SL.Free;
  end;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTRLEReader.Suite);
  RegisterTest(TestTRLEWriter.Suite);
end.

